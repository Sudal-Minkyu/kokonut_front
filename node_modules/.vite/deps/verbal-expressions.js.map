{
  "version": 3,
  "sources": ["../../verbal-expressions/VerbalExpressions.js"],
  "sourcesContent": ["/**\r\n * @file VerbalExpressions JavaScript Library\r\n * @version 0.3.0\r\n * @license MIT\r\n *\r\n * @see https://github.com/VerbalExpressions/JSVerbalExpressions\r\n */\r\n\r\n/**\r\n * Define the VerbalExpression class\r\n *\r\n * @class VerbalExpression\r\n * @extends {RegExp}\r\n */\r\nclass VerbalExpression extends RegExp {\r\n    /**\r\n     * Creates an instance of VerbalExpression.\r\n     * @constructor\r\n     * @alias VerEx\r\n     * @memberof VerbalExpression\r\n     */\r\n    constructor() {\r\n        // Call the `RegExp` constructor so that `this` can be used\r\n        super('', 'gm');\r\n\r\n        // Variables to hold the expression construction in order\r\n        this._prefixes = '';\r\n        this._source = '';\r\n        this._suffixes = '';\r\n        this._modifiers = 'gm'; // 'global, multiline' matching by default\r\n    }\r\n\r\n    // Utility //\r\n\r\n    /**\r\n     * Escape meta-characters in the parameter and make it safe for adding to the expression\r\n     * @static\r\n     * @param {(string|RegExp|number)} value object to sanitize\r\n     * @returns {string} sanitized value\r\n     * @memberof VerbalExpression\r\n     */\r\n    static sanitize(value) {\r\n        if (value instanceof RegExp) {\r\n            return value.source;\r\n        }\r\n\r\n        if (typeof value === 'number') {\r\n            return value;\r\n        }\r\n\r\n        if (typeof value !== 'string') {\r\n            return '';\r\n        }\r\n\r\n        // Regular expression to match meta characters\r\n        // https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/regexp\r\n        const toEscape = /([\\].|*?+(){}^$\\\\:=[])/g;\r\n\r\n        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/lastMatch\r\n        const lastMatch = '$&';\r\n\r\n        // Escape meta characters\r\n        return value.replace(toEscape, `\\\\${lastMatch}`);\r\n    }\r\n\r\n    /**\r\n     * Add stuff to the expression and compile the new expression so it's ready to be used.\r\n     * @param {(string|number)} [value=''] stuff to add\r\n     * @returns {VerbalExpression} recompiled instance of VerbalExpression\r\n     * @memberof VerbalExpression\r\n     */\r\n    add(value = '') {\r\n        this._source += value;\r\n        const pattern = this._prefixes + this._source + this._suffixes;\r\n\r\n        this.compile(pattern, this._modifiers);\r\n\r\n        return this;\r\n    }\r\n\r\n    // Rules //\r\n\r\n    /**\r\n     * Control start-of-line matching\r\n     * @param {boolean} [enable=true] whether to enable this behaviour\r\n     * @returns {VerbalExpression} recompiled instance of VerbalExpression\r\n     * @memberof VerbalExpression\r\n     */\r\n    startOfLine(enable = true) {\r\n        this._prefixes = enable ? '^' : '';\r\n        return this.add();\r\n    }\r\n\r\n    /**\r\n     * Control end-of-line matching\r\n     * @param {boolean} [enable=true] whether to enable this behaviour\r\n     * @returns {VerbalExpression} recompiled instance of VerbalExpression\r\n     * @memberof VerbalExpression\r\n     */\r\n    endOfLine(enable = true) {\r\n        this._suffixes = enable ? '$' : '';\r\n        return this.add();\r\n    }\r\n\r\n    /**\r\n     * Look for the value passed\r\n     * @param {(string|RegExp|number)} value value to find\r\n     * @returns {VerbalExpression} recompiled instance of VerbalExpression\r\n     * @memberof VerbalExpression\r\n     */\r\n    then(value) {\r\n        value = VerbalExpression.sanitize(value);\r\n        return this.add(`(?:${value})`);\r\n    }\r\n\r\n    /**\r\n     * Alias for then() to allow for readable syntax when then() is the first method in the chain.\r\n     * @param {(string|RegExp|numer)} value value to find\r\n     * @returns {VerbalExpression} recompiled instance of VerbalExpression\r\n     * @memberof VerbalExpression\r\n     */\r\n    find(value) {\r\n        return this.then(value);\r\n    }\r\n\r\n    /**\r\n     * Add optional values\r\n     * @param {(string|RegExp|number)} value value to find\r\n     * @returns {VerbalExpression} recompiled instance of VerbalExpression\r\n     * @memberof VerbalExpression\r\n     */\r\n    maybe(value) {\r\n        value = VerbalExpression.sanitize(value);\r\n        return this.add(`(?:${value})?`);\r\n    }\r\n\r\n    /**\r\n     * Add alternative expressions\r\n     * @param {(string|RegExp|number)} value value to find\r\n     * @returns {VerbalExpression} recompiled instance of VerbalExpression\r\n     * @memberof VerbalExpression\r\n     */\r\n    or(value) {\r\n        this._prefixes += '(?:';\r\n        this._suffixes = `)${this._suffixes}`;\r\n\r\n        this.add(')|(?:');\r\n\r\n        if (value) {\r\n            this.then(value);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Any character any number of times\r\n     * @returns {VerbalExpression} recompiled instance of VerbalExpression\r\n     * @memberof VerbalExpression\r\n     */\r\n    anything() {\r\n        return this.add('(?:.*)');\r\n    }\r\n\r\n    /**\r\n     * Anything but these characters\r\n     * @param {(string|number|string[]|number[])} value characters to not match\r\n     * @returns {VerbalExpression} recompiled instance of VerbalExpression\r\n     * @memberof VerbalExpression\r\n     */\r\n    anythingBut(value) {\r\n        if (Array.isArray(value)) {\r\n            value = value.join('');\r\n        }\r\n\r\n        value = VerbalExpression.sanitize(value);\r\n        return this.add(`(?:[^${value}]*)`);\r\n    }\r\n\r\n    /**\r\n     * Any character(s) at least once\r\n     * @returns {VerbalExpression} recompiled instance of VerbalExpression\r\n     * @memberof VerbalExpression\r\n     */\r\n    something() {\r\n        return this.add('(?:.+)');\r\n    }\r\n\r\n    /**\r\n     * Any character at least one time except for these characters\r\n     * @param {(string|number|string[]|number[])} value characters to not match\r\n     * @returns {VerbalExpression} recompiled instance of VerbalExpression\r\n     * @memberof VerbalExpression\r\n     */\r\n    somethingBut(value) {\r\n        if (Array.isArray(value)) {\r\n            value = value.join('');\r\n        }\r\n\r\n        value = VerbalExpression.sanitize(value);\r\n        return this.add(`(?:[^${value}]+)`);\r\n    }\r\n\r\n    /**\r\n     * Match any of the given characters\r\n     * @param {(string|number|string[]|number[])} value characters to match\r\n     * @returns {VerbalExpression} recompiled instance of VerbalExpression\r\n     * @memberof VerbalExpression\r\n     */\r\n    anyOf(value) {\r\n        if (Array.isArray(value)) {\r\n            value = value.join('');\r\n        }\r\n\r\n        value = VerbalExpression.sanitize(value);\r\n        return this.add(`[${value}]`);\r\n    }\r\n\r\n    /**\r\n     * Shorthand for anyOf(value)\r\n     * @param {string|number} value value to find\r\n     * @returns {VerbalExpression} recompiled instance of VerbalExpression\r\n     * @memberof VerbalExpression\r\n     */\r\n    any(value) {\r\n        return this.anyOf(value);\r\n    }\r\n\r\n    /**\r\n     * Ensure that the parameter does not follow\r\n     * @param {string|number} value\r\n     * @returns {VerbalExpression} recompiled instance of VerbalExpression\r\n     * @memberof VerbalExpression\r\n     */\r\n    not(value) {\r\n        value = VerbalExpression.sanitize(value);\r\n        this.add(`(?!${value})`);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Matching any character within a range of characters\r\n     * Usage: .range( from, to [, from, to ... ] )\r\n     * @param {...string} ranges characters denoting beginning and ending of ranges\r\n     * @returns {VerbalExpression} recompiled instance of VerbalExpression\r\n     * @memberof VerbalExpression\r\n     */\r\n    range(...ranges) {\r\n        let value = '';\r\n\r\n        for (let i = 1; i < ranges.length; i += 2) {\r\n            const from = VerbalExpression.sanitize(ranges[i - 1]);\r\n            const to = VerbalExpression.sanitize(ranges[i]);\r\n\r\n            value += `${from}-${to}`;\r\n        }\r\n\r\n        return this.add(`[${value}]`);\r\n    }\r\n\r\n    // Special characters //\r\n\r\n    /**\r\n     * Match a Line break\r\n     * @returns {VerbalExpression} recompiled instance of VerbalExpression\r\n     * @memberof VerbalExpression\r\n     */\r\n    lineBreak() {\r\n        return this.add('(?:\\\\r\\\\n|\\\\r|\\\\n)'); // Unix(LF) + Windows(CRLF)\r\n    }\r\n\r\n    /**\r\n     * A shorthand for lineBreak() for html-minded users\r\n     * @returns {VerbalExpression} recompiled instance of VerbalExpression\r\n     * @memberof VerbalExpression\r\n     */\r\n    br() {\r\n        return this.lineBreak();\r\n    }\r\n\r\n    /**\r\n     * Match a tab character\r\n     * @returns {VerbalExpression} recompiled instance of VerbalExpression\r\n     * @memberof VerbalExpression\r\n     */\r\n    tab() {\r\n        return this.add('\\\\t');\r\n    }\r\n\r\n    /**\r\n     * Match any alphanumeric\r\n     * @returns {VerbalExpression} recompiled instance of VerbalExpression\r\n     * @memberof VerbalExpression\r\n     */\r\n    word() {\r\n        return this.add('\\\\w+');\r\n    }\r\n\r\n    /**\r\n     * Match a single digit\r\n     * @returns {VerbalExpression} recompiled instance of VerbalExpression\r\n     * @memberof VerbalExpression\r\n     */\r\n    digit() {\r\n        return this.add('\\\\d');\r\n    }\r\n\r\n    /**\r\n     * Match a single whitespace\r\n     * @returns {VerbalExpression} recompiled instance of VerbalExpression\r\n     * @memberof VerbalExpression\r\n     */\r\n    whitespace() {\r\n        return this.add('\\\\s');\r\n    }\r\n\r\n    // Modifiers //\r\n\r\n    /**\r\n     * Add a regex modifier/flag\r\n     * @param {string} modifier modifier to add\r\n     * @returns {VerbalExpression} recompiled instance of VerbalExpression\r\n     * @memberof VerbalExpression\r\n     */\r\n    addModifier(modifier) {\r\n        if (!this._modifiers.includes(modifier)) {\r\n            this._modifiers += modifier;\r\n        }\r\n\r\n        return this.add();\r\n    }\r\n\r\n    /**\r\n     * Remove modifier\r\n     * @param {string} modifier modifier to remove\r\n     * @returns {VerbalExpression} recompiled instance of VerbalExpression\r\n     * @memberof VerbalExpression\r\n     */\r\n    removeModifier(modifier) {\r\n        this._modifiers = this._modifiers.replace(modifier, '');\r\n        return this.add();\r\n    }\r\n\r\n    /**\r\n     * Control case-insensitive matching\r\n     * @param {boolean} [enable=true] whether to enable this behaviour\r\n     * @returns {VerbalExpression} recompiled instance of VerbalExpression\r\n     * @memberof VerbalExpression\r\n     */\r\n    withAnyCase(enable = true) {\r\n        return enable ? this.addModifier('i') : this.removeModifier('i');\r\n    }\r\n\r\n    /**\r\n     * Default behaviour is with \"g\" modifier, so we can turn this another way around than other modifiers\r\n     * @param {boolean} [enable=true] whether to enable this behaviour\r\n     * @returns {VerbalExpression} recompiled instance of VerbalExpression\r\n     * @memberof VerbalExpression\r\n     */\r\n    stopAtFirst(enable = true) {\r\n        return enable ? this.removeModifier('g') : this.addModifier('g');\r\n    }\r\n\r\n    /**\r\n     * Control the multiline modifier\r\n     * @param {boolean} [enable=true] whether to enable this behaviour\r\n     * @returns {VerbalExpression} recompiled instance of VerbalExpression\r\n     * @memberof VerbalExpression\r\n     */\r\n    searchOneLine(enable = true) {\r\n        return enable ? this.removeModifier('m') : this.addModifier('m');\r\n    }\r\n\r\n    // Loops //\r\n\r\n    /**\r\n     * Repeat the previous item exactly n times or between n and m times\r\n     * @returns {VerbalExpression} recompiled instance of VerbalExpression\r\n     * @memberof VerbalExpression\r\n     */\r\n    repeatPrevious(...quantity) {\r\n        const isInteger = /\\d+/;\r\n        const values = quantity.filter(argument => isInteger.test(argument));\r\n\r\n        if (values.length === 0 || values.length > 2) {\r\n            return this;\r\n        }\r\n\r\n        this.add(`{${values.join(',')}}`);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Repeat the previous at least once\r\n     * @returns {VerbalExpression} recompiled instance of VerbalExpression\r\n     * @memberof VerbalExpression\r\n     */\r\n    oneOrMore() {\r\n        return this.add('+');\r\n    }\r\n\r\n    /**\r\n     * Match the value zero or more times\r\n     * @param {string} value value to find\r\n     * @param {integer} [lower] minimum number of times the value should be repeated\r\n     * @param {integer} [upper] maximum number of times the value should be repeated\r\n     * @returns {VerbalExpression} recompiled instance of VerbalExpression\r\n     * @memberof VerbalExpression\r\n     */\r\n    multiple(value, lower, upper) {\r\n        if (value !== undefined) {\r\n            value = VerbalExpression.sanitize(value);\r\n            this.add(`(?:${value})`);\r\n        }\r\n\r\n        if (lower === undefined && upper === undefined) {\r\n            this.add('*'); // Any number of times\r\n        } else if (lower !== undefined && upper === undefined) {\r\n            this.add(`{${lower},}`);\r\n        } else if (lower !== undefined && upper !== undefined) {\r\n            this.add(`{${lower},${upper}}`);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    // Capture groups //\r\n\r\n    /**\r\n     * Starts a capturing group\r\n     * @returns {VerbalExpression} recompiled instance of VerbalExpression\r\n     * @memberof VerbalExpression\r\n     */\r\n    beginCapture() {\r\n        // Add the end of the capture group to the suffixes temporarily so that compilation continues to work\r\n        this._suffixes += ')';\r\n        return this.add('(');\r\n    }\r\n\r\n    /**\r\n     * Ends a capturing group\r\n     * @returns {VerbalExpression} recompiled instance of VerbalExpression\r\n     * @memberof VerbalExpression\r\n     */\r\n    endCapture() {\r\n        // Remove the last parenthesis from the _suffixes and add it to the regex\r\n        this._suffixes = this._suffixes.slice(0, -1);\r\n        return this.add(')');\r\n    }\r\n\r\n    // Miscellaneous //\r\n\r\n    /**\r\n     * Shorthand function for the string.replace function to allow for a more logical flow\r\n     * @param {string} source string to search for\r\n     * @param {string} value value to replace with\r\n     * @returns {VerbalExpression} recompiled instance of VerbalExpression\r\n     * @memberof VerbalExpression\r\n     */\r\n    replace(source, value) {\r\n        source = source.toString();\r\n        return source.replace(this, value);\r\n    }\r\n\r\n    /**\r\n     * Convert to RegExp object\r\n     * @returns {RegExp} equivalent RegExp instance\r\n     * @memberof VerbalExpression\r\n     */\r\n    toRegExp() {\r\n        const components = this.toString().match(/\\/(.*)\\/([gimuy]+)?/);\r\n        const pattern = components[1];\r\n        const flags = components[2];\r\n\r\n        return new RegExp(pattern, flags);\r\n    }\r\n}\r\n\r\n/**\r\n * Return a new instance of `VerbalExpression`\r\n * @export\r\n * @returns {VerbalExpression} new instance\r\n */\r\nfunction VerEx() { // eslint-disable-line no-unused-vars\r\n    const instance = new VerbalExpression();\r\n    instance.sanitize = VerbalExpression.sanitize;\r\n    return instance;\r\n}\r\n"],
  "mappings": "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",
  "names": ["VerbalExpression", "_source", "enable", "_prefixes", "value", "add", "Array", "isArray", "sanitize", "anyOf", "_modifiers", "modifier", "replace", "addModifier", "removeModifier", "isInteger", "quantity", "source", "toString", "RegExp", "lastMatch", "VerEx", "instance"]
}
