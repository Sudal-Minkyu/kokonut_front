import {
  writable
} from "./chunk-DY7FSUYH.js";
import {
  fade
} from "./chunk-YCKTV2FB.js";
import "./chunk-M6MB33T7.js";
import "./chunk-6A2TAOKG.js";
import {
  SvelteComponentDev,
  action_destroyer,
  add_location,
  add_render_callback,
  append_dev,
  append_styles,
  assign,
  attr_dev,
  binding_callbacks,
  check_outros,
  construct_svelte_component_dev,
  createEventDispatcher,
  create_bidirectional_transition,
  create_component,
  create_slot,
  destroy_component,
  destroy_each,
  detach_dev,
  dispatch_dev,
  element,
  empty,
  get_all_dirty_from_scope,
  get_slot_changes,
  get_spread_object,
  get_spread_update,
  globals,
  group_outros,
  init,
  insert_dev,
  is_function,
  listen_dev,
  mount_component,
  noop,
  onDestroy,
  onMount,
  run_all,
  safe_not_equal,
  set_attributes,
  set_style,
  space,
  svg_element,
  toggle_class,
  transition_in,
  transition_out,
  update_slot_base,
  validate_each_argument,
  validate_slots
} from "./chunk-K6MJRMI7.js";
import {
  __export
} from "./chunk-TFWDKVI3.js";

// node_modules/svelte-images/src/Images/Image.svelte
var file = "node_modules/svelte-images/src/Images/Image.svelte";
function add_css(target) {
  append_styles(target, "svelte-1ayq9qu", "img.svelte-1ayq9qu{opacity:0;transition:all 1s ease}.after-load.svelte-1ayq9qu{transition:none}.loaded.svelte-1ayq9qu{opacity:1}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiSW1hZ2Uuc3ZlbHRlIiwibWFwcGluZ3MiOiJBQWlCRSxHQUFHLGVBQUMsQ0FBQSxBQUNGLE9BQU8sQ0FBRSxDQUFDLENBQ1YsVUFBVSxDQUFFLEdBQUcsQ0FBQyxFQUFFLENBQUMsSUFBSSxBQUN6QixDQUFBLEFBQ0EsV0FBVyxlQUFDLENBQUEsQUFDVixVQUFVLENBQUUsSUFBSSxBQUNsQixDQUFBLEFBQ0EsT0FBTyxlQUFDLENBQUEsQUFDTixPQUFPLENBQUUsQ0FBQyxBQUNaLENBQUEiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiSW1hZ2Uuc3ZlbHRlIl19 */");
}
function create_fragment(ctx) {
  let img;
  let img_alt_value;
  let load_action;
  let mounted;
  let dispose;
  let img_levels = [
    /*imageProps*/
    ctx[0],
    {
      alt: img_alt_value = /*imageProps*/
      ctx[0].alt || ""
    }
  ];
  let img_data = {};
  for (let i = 0; i < img_levels.length; i += 1) {
    img_data = assign(img_data, img_levels[i]);
  }
  const block = {
    c: function create() {
      img = element("img");
      set_attributes(img, img_data);
      toggle_class(img, "blur", !/*loaded*/
      ctx[2]);
      toggle_class(
        img,
        "after-load",
        /*afterLoad*/
        ctx[3]
      );
      toggle_class(
        img,
        "loaded",
        /*loaded*/
        ctx[2]
      );
      toggle_class(img, "svelte-1ayq9qu", true);
      add_location(img, file, 29, 0, 458);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, img, anchor);
      if (!mounted) {
        dispose = [
          listen_dev(
            img,
            "click",
            function() {
              if (is_function(
                /*onClick*/
                ctx[1]
              ))
                ctx[1].apply(this, arguments);
            },
            false,
            false,
            false
          ),
          action_destroyer(load_action = /*load*/
          ctx[4].call(null, img))
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, [dirty]) {
      ctx = new_ctx;
      set_attributes(img, img_data = get_spread_update(img_levels, [
        dirty & /*imageProps*/
        1 && /*imageProps*/
        ctx[0],
        dirty & /*imageProps*/
        1 && img_alt_value !== (img_alt_value = /*imageProps*/
        ctx[0].alt || "") && { alt: img_alt_value }
      ]));
      toggle_class(img, "blur", !/*loaded*/
      ctx[2]);
      toggle_class(
        img,
        "after-load",
        /*afterLoad*/
        ctx[3]
      );
      toggle_class(
        img,
        "loaded",
        /*loaded*/
        ctx[2]
      );
      toggle_class(img, "svelte-1ayq9qu", true);
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(img);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Image", slots, []);
  let { lazy = true } = $$props;
  let { imageProps = {} } = $$props;
  let { onClick = () => {
  } } = $$props;
  let className = "";
  let loaded = !lazy;
  let afterLoad = false;
  function load(img) {
    img.onload = () => {
      $$invalidate(2, loaded = true);
      setTimeout(() => $$invalidate(3, afterLoad = true), 1500);
    };
  }
  const writable_props = ["lazy", "imageProps", "onClick"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Image> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("lazy" in $$props2)
      $$invalidate(5, lazy = $$props2.lazy);
    if ("imageProps" in $$props2)
      $$invalidate(0, imageProps = $$props2.imageProps);
    if ("onClick" in $$props2)
      $$invalidate(1, onClick = $$props2.onClick);
  };
  $$self.$capture_state = () => ({
    lazy,
    imageProps,
    onClick,
    className,
    loaded,
    afterLoad,
    load
  });
  $$self.$inject_state = ($$props2) => {
    if ("lazy" in $$props2)
      $$invalidate(5, lazy = $$props2.lazy);
    if ("imageProps" in $$props2)
      $$invalidate(0, imageProps = $$props2.imageProps);
    if ("onClick" in $$props2)
      $$invalidate(1, onClick = $$props2.onClick);
    if ("className" in $$props2)
      className = $$props2.className;
    if ("loaded" in $$props2)
      $$invalidate(2, loaded = $$props2.loaded);
    if ("afterLoad" in $$props2)
      $$invalidate(3, afterLoad = $$props2.afterLoad);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [imageProps, onClick, loaded, afterLoad, load, lazy];
}
var Image = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment, safe_not_equal, { lazy: 5, imageProps: 0, onClick: 1 }, add_css);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Image",
      options,
      id: create_fragment.name
    });
  }
  get lazy() {
    throw new Error("<Image>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lazy(value) {
    throw new Error("<Image>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get imageProps() {
    throw new Error("<Image>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set imageProps(value) {
    throw new Error("<Image>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onClick() {
    throw new Error("<Image>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onClick(value) {
    throw new Error("<Image>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Image_default = Image;

// node_modules/svelte-images/src/Images/carousel.js
var carousel_exports = {};
__export(carousel_exports, {
  Modal: () => Modal_default,
  close: () => close2,
  open: () => open2
});

// node_modules/svelte-images/src/Images/modalStore.js
var modalStore = writable({});
var open = (Component, props) => {
  modalStore.set({ isOpen: true, Component, props });
};
var close = () => {
  modalStore.set({ isOpen: false, Component: null, props: {} });
};

// node_modules/svelte-images/src/Images/Modal.svelte
var file2 = "node_modules/svelte-images/src/Images/Modal.svelte";
function add_css2(target) {
  append_styles(target, "svelte-rppnts", ".svelte-rppnts{box-sizing:border-box}.bg.svelte-rppnts{position:fixed;z-index:1000;display:flex;flex-direction:column;justify-content:center;width:100vw;height:100vh;background:rgba(0, 0, 0, 0.66);transition:opacity 200ms ease 0s;top:0;left:0}.window-wrap.svelte-rppnts{position:relative}.content.svelte-rppnts{position:relative}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTW9kYWwuc3ZlbHRlIiwibWFwcGluZ3MiOiJBQW1DRSxjQUFFLENBQUEsQUFDQSxVQUFVLENBQUUsVUFBVSxBQUN4QixDQUFBLEFBQ0EsR0FBRyxjQUFDLENBQUEsQUFDRixRQUFRLENBQUUsS0FBSyxDQUNmLE9BQU8sQ0FBRSxJQUFJLENBQ2IsT0FBTyxDQUFFLElBQUksQ0FDYixjQUFjLENBQUUsTUFBTSxDQUN0QixlQUFlLENBQUUsTUFBTSxDQUN2QixLQUFLLENBQUUsS0FBSyxDQUNaLE1BQU0sQ0FBRSxLQUFLLENBQ2IsVUFBVSxDQUFFLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQy9CLFVBQVUsQ0FBRSxPQUFPLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQ2pDLEdBQUcsQ0FBRSxDQUFDLENBQ04sSUFBSSxDQUFFLENBQUMsQUFDVCxDQUFBLEFBQ0EsWUFBWSxjQUFDLENBQUEsQUFDWCxRQUFRLENBQUUsUUFBUSxBQUNwQixDQUFBLEFBQ0EsUUFBUSxjQUFDLENBQUEsQUFDUCxRQUFRLENBQUUsUUFBUSxBQUNwQixDQUFBIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIk1vZGFsLnN2ZWx0ZSJdfQ== */");
}
function create_if_block(ctx) {
  let div2;
  let div1;
  let div0;
  let switch_instance;
  let div1_transition;
  let div2_transition;
  let current;
  let mounted;
  let dispose;
  const switch_instance_spread_levels = [
    /*props*/
    ctx[1]
  ];
  var switch_value = (
    /*Component*/
    ctx[2]
  );
  function switch_props(ctx2) {
    let switch_instance_props = {};
    for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
      switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    }
    return {
      props: switch_instance_props,
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    c: function create() {
      div2 = element("div");
      div1 = element("div");
      div0 = element("div");
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      attr_dev(div0, "class", "content svelte-rppnts");
      add_location(div0, file2, 72, 8, 1464);
      attr_dev(div1, "class", "window-wrap svelte-rppnts");
      add_location(div1, file2, 68, 6, 1353);
      attr_dev(div2, "class", "bg svelte-rppnts");
      add_location(div2, file2, 63, 4, 1219);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div2, anchor);
      append_dev(div2, div1);
      append_dev(div1, div0);
      if (switch_instance)
        mount_component(switch_instance, div0, null);
      ctx[9](div1);
      ctx[10](div2);
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          div2,
          "click",
          /*handleOuterClick*/
          ctx[6],
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      const switch_instance_changes = dirty & /*props*/
      2 ? get_spread_update(switch_instance_spread_levels, [get_spread_object(
        /*props*/
        ctx2[1]
      )]) : {};
      if (switch_value !== (switch_value = /*Component*/
      ctx2[2])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, div0, null);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      add_render_callback(() => {
        if (!div1_transition)
          div1_transition = create_bidirectional_transition(div1, fade, { duration: 300 }, true);
        div1_transition.run(1);
      });
      add_render_callback(() => {
        if (!div2_transition)
          div2_transition = create_bidirectional_transition(div2, fade, { duration: 300 }, true);
        div2_transition.run(1);
      });
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      if (!div1_transition)
        div1_transition = create_bidirectional_transition(div1, fade, { duration: 300 }, false);
      div1_transition.run(0);
      if (!div2_transition)
        div2_transition = create_bidirectional_transition(div2, fade, { duration: 300 }, false);
      div2_transition.run(0);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div2);
      if (switch_instance)
        destroy_component(switch_instance);
      ctx[9](null);
      if (detaching && div1_transition)
        div1_transition.end();
      ctx[10](null);
      if (detaching && div2_transition)
        div2_transition.end();
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(63:2) {#if isOpen}",
    ctx
  });
  return block;
}
function create_fragment2(ctx) {
  let div;
  let t;
  let current;
  let mounted;
  let dispose;
  let if_block = (
    /*isOpen*/
    ctx[0] && create_if_block(ctx)
  );
  const default_slot_template = (
    /*#slots*/
    ctx[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    null
  );
  const block = {
    c: function create() {
      div = element("div");
      if (if_block)
        if_block.c();
      t = space();
      if (default_slot)
        default_slot.c();
      attr_dev(div, "class", "svelte-rppnts");
      add_location(div, file2, 61, 0, 1194);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (if_block)
        if_block.m(div, null);
      append_dev(div, t);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          window,
          "keyup",
          /*handleKeyup*/
          ctx[5],
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*isOpen*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*isOpen*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div, t);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        128)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (if_block)
        if_block.d();
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance2($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Modal", slots, ["default"]);
  let state = {};
  let isOpen = false;
  let props = null;
  let Component = null;
  let background;
  let wrap;
  const handleKeyup = ({ key }) => {
    if (Component && key === "Escape") {
      event.preventDefault();
      close();
    }
  };
  const handleOuterClick = (event2) => {
    if (event2.target === background || event2.target === wrap) {
      event2.preventDefault();
      close();
    }
  };
  const unsubscribe = modalStore.subscribe((value) => {
    $$invalidate(2, Component = value.Component);
    $$invalidate(1, props = value.props);
    $$invalidate(0, isOpen = value.isOpen);
  });
  onDestroy(unsubscribe);
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Modal> was created with unknown prop '${key}'`);
  });
  function div1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      wrap = $$value;
      $$invalidate(4, wrap);
    });
  }
  function div2_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      background = $$value;
      $$invalidate(3, background);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2)
      $$invalidate(7, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    onDestroy,
    fade,
    modalStore,
    open,
    close,
    state,
    isOpen,
    props,
    Component,
    background,
    wrap,
    handleKeyup,
    handleOuterClick,
    unsubscribe
  });
  $$self.$inject_state = ($$props2) => {
    if ("state" in $$props2)
      state = $$props2.state;
    if ("isOpen" in $$props2)
      $$invalidate(0, isOpen = $$props2.isOpen);
    if ("props" in $$props2)
      $$invalidate(1, props = $$props2.props);
    if ("Component" in $$props2)
      $$invalidate(2, Component = $$props2.Component);
    if ("background" in $$props2)
      $$invalidate(3, background = $$props2.background);
    if ("wrap" in $$props2)
      $$invalidate(4, wrap = $$props2.wrap);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    isOpen,
    props,
    Component,
    background,
    wrap,
    handleKeyup,
    handleOuterClick,
    $$scope,
    slots,
    div1_binding,
    div2_binding
  ];
}
var Modal = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance2, create_fragment2, safe_not_equal, {}, add_css2);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Modal",
      options,
      id: create_fragment2.name
    });
  }
};
var Modal_default = Modal;

// node_modules/svelte-images/src/util.js
function debounce(func, wait, immediate) {
  var timeout;
  return function() {
    var context = this, args = arguments;
    var later = function() {
      timeout = null;
      if (!immediate)
        func.apply(context, args);
    };
    var callNow = immediate && !timeout;
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
    if (callNow)
      func.apply(context, args);
  };
}

// node_modules/svelte-images/src/Images/ClickOutside.svelte
var file3 = "node_modules/svelte-images/src/Images/ClickOutside.svelte";
function create_fragment3(ctx) {
  let t;
  let div;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    null
  );
  const block = {
    c: function create() {
      t = space();
      div = element("div");
      if (default_slot)
        default_slot.c();
      attr_dev(
        div,
        "class",
        /*className*/
        ctx[0]
      );
      add_location(div, file3, 26, 0, 656);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      ctx[6](div);
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          document.body,
          "click",
          /*onClickOutside*/
          ctx[2],
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*className*/
      1) {
        attr_dev(
          div,
          "class",
          /*className*/
          ctx2[0]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
      ctx[6](null);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment3.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance3($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ClickOutside", slots, ["default"]);
  let { exclude = [] } = $$props;
  let { className } = $$props;
  let child;
  const dispatch = createEventDispatcher();
  function isExcluded(target) {
    var parent = target;
    while (parent) {
      if (exclude.indexOf(parent) >= 0 || parent === child) {
        return true;
      }
      parent = parent.parentNode;
    }
    return false;
  }
  function onClickOutside(event2) {
    if (!isExcluded(event2.target)) {
      event2.preventDefault();
      dispatch("clickoutside");
    }
  }
  $$self.$$.on_mount.push(function() {
    if (className === void 0 && !("className" in $$props || $$self.$$.bound[$$self.$$.props["className"]])) {
      console.warn("<ClickOutside> was created without expected prop 'className'");
    }
  });
  const writable_props = ["exclude", "className"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<ClickOutside> was created with unknown prop '${key}'`);
  });
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      child = $$value;
      $$invalidate(1, child);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("exclude" in $$props2)
      $$invalidate(3, exclude = $$props2.exclude);
    if ("className" in $$props2)
      $$invalidate(0, className = $$props2.className);
    if ("$$scope" in $$props2)
      $$invalidate(4, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    exclude,
    className,
    child,
    dispatch,
    isExcluded,
    onClickOutside
  });
  $$self.$inject_state = ($$props2) => {
    if ("exclude" in $$props2)
      $$invalidate(3, exclude = $$props2.exclude);
    if ("className" in $$props2)
      $$invalidate(0, className = $$props2.className);
    if ("child" in $$props2)
      $$invalidate(1, child = $$props2.child);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [className, child, onClickOutside, exclude, $$scope, slots, div_binding];
}
var ClickOutside = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance3, create_fragment3, safe_not_equal, { exclude: 3, className: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ClickOutside",
      options,
      id: create_fragment3.name
    });
  }
  get exclude() {
    throw new Error("<ClickOutside>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set exclude(value) {
    throw new Error("<ClickOutside>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get className() {
    throw new Error("<ClickOutside>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set className(value) {
    throw new Error("<ClickOutside>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ClickOutside_default = ClickOutside;

// node_modules/svelte-images/src/Images/Carousel.svelte
var { window: window_1 } = globals;
var file4 = "node_modules/svelte-images/src/Images/Carousel.svelte";
function add_css3(target) {
  append_styles(target, "svelte-m9pjbw", ".container.svelte-m9pjbw.svelte-m9pjbw{position:relative}.carousel.svelte-m9pjbw.svelte-m9pjbw{position:relative;overflow:hidden;display:inline-flex;transition:transform 500ms cubic-bezier(0.23, 1, 0.32, 1) 0s,\n      opacity 500ms cubic-bezier(0.23, 1, 0.32, 1) 0s}.nav.svelte-m9pjbw.svelte-m9pjbw{display:flex;box-sizing:border-box;-webkit-box-align:center;align-items:center;-webkit-box-pack:justify;justify-content:space-between;position:absolute;width:100vw;height:100%;z-index:4}.carousel img{height:auto;max-width:80vw;max-height:85vh;margin:auto;user-select:none}.carousel .click-outside-wrapper{display:flex}.img-container.svelte-m9pjbw.svelte-m9pjbw{display:flex;justify-content:center;width:100vw}.nav.svelte-m9pjbw button.svelte-m9pjbw{cursor:pointer;background:transparent;border:none;outline:none !important;background:rgba(255, 255, 255, 0.2);border-radius:50%;width:5em;height:5em;display:flex;color:white;margin:0 17px}.nav.svelte-m9pjbw button.svelte-m9pjbw:hover{background:rgba(255, 255, 255, 0.3)}.nav.svelte-m9pjbw svg.svelte-m9pjbw{display:inline-block;fill:currentcolor;height:5em;width:5em;stroke:currentcolor;stroke-width:0}@media(max-width: 800px){.carousel img{max-width:75vw}.nav.svelte-m9pjbw button.svelte-m9pjbw{margin:0 12px;width:4em;height:4em}.nav.svelte-m9pjbw svg.svelte-m9pjbw{width:4em;height:4em}}@media(max-width: 550px){.carousel img{max-width:100vw}.nav.svelte-m9pjbw button.svelte-m9pjbw{margin:0 10px;width:3em;height:3em}.nav.svelte-m9pjbw svg.svelte-m9pjbw{width:3em;height:3em}}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQ2Fyb3VzZWwuc3ZlbHRlIiwibWFwcGluZ3MiOiJBQTRDRSxVQUFVLDRCQUFDLENBQUEsQUFDVCxRQUFRLENBQUUsUUFBUSxBQUNwQixDQUFBLEFBQ0EsU0FBUyw0QkFBQyxDQUFBLEFBQ1IsUUFBUSxDQUFFLFFBQVEsQ0FDbEIsUUFBUSxDQUFFLE1BQU0sQ0FDaEIsT0FBTyxDQUFFLFdBQVcsQ0FDcEIsVUFBVSxDQUFFLFNBQVMsQ0FBQyxLQUFLLENBQUMsYUFBYSxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUE7TUFDM0QsT0FBTyxDQUFDLEtBQUssQ0FBQyxhQUFhLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQUFDbkQsQ0FBQSxBQUNBLElBQUksNEJBQUMsQ0FBQSxBQUNILE9BQU8sQ0FBRSxJQUFJLENBQ2IsVUFBVSxDQUFFLFVBQVUsQ0FDdEIsaUJBQWlCLENBQUUsTUFBTSxDQUN6QixXQUFXLENBQUUsTUFBTSxDQUNuQixnQkFBZ0IsQ0FBRSxPQUFPLENBQ3pCLGVBQWUsQ0FBRSxhQUFhLENBQzlCLFFBQVEsQ0FBRSxRQUFRLENBQ2xCLEtBQUssQ0FBRSxLQUFLLENBQ1osTUFBTSxDQUFFLElBQUksQ0FDWixPQUFPLENBQUUsQ0FBQyxBQUNaLENBQUEsQUFDUSxhQUFhLEFBQUUsQ0FBQSxBQUNyQixNQUFNLENBQUUsSUFBSSxDQUNaLFNBQVMsQ0FBRSxJQUFJLENBQ2YsVUFBVSxDQUFFLElBQUksQ0FDaEIsTUFBTSxDQUFFLElBQUksQ0FDWixXQUFXLENBQUUsSUFBSSxBQUNuQixDQUFBLEFBQ1EsZ0NBQWdDLEFBQUUsQ0FBQSxBQUN4QyxPQUFPLENBQUUsSUFBSSxBQUNmLENBQUEsQUFDQSxjQUFjLDRCQUFDLENBQUEsQUFDYixPQUFPLENBQUUsSUFBSSxDQUNiLGVBQWUsQ0FBRSxNQUFNLENBQ3ZCLEtBQUssQ0FBRSxLQUFLLEFBQ2QsQ0FBQSxBQUNBLGtCQUFJLENBQUMsTUFBTSxjQUFDLENBQUEsQUFDVixNQUFNLENBQUUsT0FBTyxDQUNmLFVBQVUsQ0FBRSxXQUFXLENBQ3ZCLE1BQU0sQ0FBRSxJQUFJLENBQ1osT0FBTyxDQUFFLElBQUksQ0FBQyxVQUFVLENBQ3hCLFVBQVUsQ0FBRSxLQUFLLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUNwQyxhQUFhLENBQUUsR0FBRyxDQUNsQixLQUFLLENBQUUsR0FBRyxDQUNWLE1BQU0sQ0FBRSxHQUFHLENBQ1gsT0FBTyxDQUFFLElBQUksQ0FDYixLQUFLLENBQUUsS0FBSyxDQUNaLE1BQU0sQ0FBRSxDQUFDLENBQUMsSUFBSSxBQUNoQixDQUFBLEFBQ0Esa0JBQUksQ0FBQyxvQkFBTSxNQUFNLEFBQUMsQ0FBQSxBQUNoQixVQUFVLENBQUUsS0FBSyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsQUFDdEMsQ0FBQSxBQUNBLGtCQUFJLENBQUMsR0FBRyxjQUFDLENBQUEsQUFDUCxPQUFPLENBQUUsWUFBWSxDQUNyQixJQUFJLENBQUUsWUFBWSxDQUNsQixNQUFNLENBQUUsR0FBRyxDQUNYLEtBQUssQ0FBRSxHQUFHLENBQ1YsTUFBTSxDQUFFLFlBQVksQ0FDcEIsWUFBWSxDQUFFLENBQUMsQUFDakIsQ0FBQSxBQUlBLE1BQU0sQUFBQyxZQUFZLEtBQUssQ0FBQyxBQUFDLENBQUEsQUFDaEIsYUFBYSxBQUFFLENBQUEsQUFDckIsU0FBUyxDQUFFLElBQUksQUFDakIsQ0FBQSxBQUNBLGtCQUFJLENBQUMsTUFBTSxjQUFDLENBQUEsQUFDVixNQUFNLENBQUUsQ0FBQyxDQUFDLElBQUksQ0FDZCxLQUFLLENBQUUsR0FBRyxDQUNWLE1BQU0sQ0FBRSxHQUFHLEFBQ2IsQ0FBQSxBQUNBLGtCQUFJLENBQUMsR0FBRyxjQUFDLENBQUEsQUFDUCxLQUFLLENBQUUsR0FBRyxDQUNWLE1BQU0sQ0FBRSxHQUFHLEFBQ2IsQ0FBQSxBQUNGLENBQUEsQUFDQSxNQUFNLEFBQUMsWUFBWSxLQUFLLENBQUMsQUFBQyxDQUFBLEFBQ2hCLGFBQWEsQUFBRSxDQUFBLEFBQ3JCLFNBQVMsQ0FBRSxLQUFLLEFBQ2xCLENBQUEsQUFDQSxrQkFBSSxDQUFDLE1BQU0sY0FBQyxDQUFBLEFBQ1YsTUFBTSxDQUFFLENBQUMsQ0FBQyxJQUFJLENBQ2QsS0FBSyxDQUFFLEdBQUcsQ0FDVixNQUFNLENBQUUsR0FBRyxBQUNiLENBQUEsQUFDQSxrQkFBSSxDQUFDLEdBQUcsY0FBQyxDQUFBLEFBQ1AsS0FBSyxDQUFFLEdBQUcsQ0FDVixNQUFNLENBQUUsR0FBRyxBQUNiLENBQUEsQUFDRixDQUFBIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIkNhcm91c2VsLnN2ZWx0ZSJdfQ== */");
}
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[16] = list[i];
  child_ctx[17] = list;
  child_ctx[18] = i;
  return child_ctx;
}
function create_each_block(ctx) {
  let div;
  let image;
  let i = (
    /*i*/
    ctx[18]
  );
  let t;
  let current;
  const assign_image = () => (
    /*image_binding*/
    ctx[12](image, i)
  );
  const unassign_image = () => (
    /*image_binding*/
    ctx[12](null, i)
  );
  let image_props = { imageProps: (
    /*image*/
    ctx[16]
  ) };
  image = new Image_default({ props: image_props, $$inline: true });
  assign_image();
  const block = {
    c: function create() {
      div = element("div");
      create_component(image.$$.fragment);
      t = space();
      attr_dev(div, "class", "img-container svelte-m9pjbw");
      add_location(div, file4, 161, 8, 3610);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      mount_component(image, div, null);
      append_dev(div, t);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (i !== /*i*/
      ctx2[18]) {
        unassign_image();
        i = /*i*/
        ctx2[18];
        assign_image();
      }
      const image_changes = {};
      if (dirty & /*images*/
      1)
        image_changes.imageProps = /*image*/
        ctx2[16];
      image.$set(image_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(image.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(image.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      unassign_image();
      destroy_component(image);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block.name,
    type: "each",
    source: "(161:6) {#each images as image, i}",
    ctx
  });
  return block;
}
function create_default_slot(ctx) {
  let each_1_anchor;
  let current;
  let each_value = (
    /*images*/
    ctx[0]
  );
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  const block = {
    c: function create() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(target, anchor);
      }
      insert_dev(target, each_1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*images, image_elements*/
      9) {
        each_value = /*images*/
        ctx2[0];
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach_dev(each_1_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot.name,
    type: "slot",
    source: '(157:4) <ClickOutside       className=\\"click-outside-wrapper\\"       on:clickoutside={handleClose}       exclude={[left_nav_button, right_nav_button, ...image_elements]}>',
    ctx
  });
  return block;
}
function create_fragment4(ctx) {
  let div2;
  let div0;
  let button0;
  let svg0;
  let path0;
  let t0;
  let button1;
  let svg1;
  let path1;
  let t1;
  let div1;
  let clickoutside;
  let div1_style_value;
  let current;
  let mounted;
  let dispose;
  clickoutside = new ClickOutside_default({
    props: {
      className: "click-outside-wrapper",
      exclude: [
        /*left_nav_button*/
        ctx[1],
        /*right_nav_button*/
        ctx[2],
        .../*image_elements*/
        ctx[3]
      ],
      $$slots: { default: [create_default_slot] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  clickoutside.$on(
    "clickoutside",
    /*handleClose*/
    ctx[8]
  );
  const block = {
    c: function create() {
      div2 = element("div");
      div0 = element("div");
      button0 = element("button");
      svg0 = svg_element("svg");
      path0 = svg_element("path");
      t0 = space();
      button1 = element("button");
      svg1 = svg_element("svg");
      path1 = svg_element("path");
      t1 = space();
      div1 = element("div");
      create_component(clickoutside.$$.fragment);
      attr_dev(path0, "d", "M15.422 16.078l-1.406 1.406-6-6 6-6 1.406 1.406-4.594 4.594z");
      add_location(path0, file4, 143, 8, 2980);
      attr_dev(svg0, "role", "presentation");
      attr_dev(svg0, "viewBox", "0 0 24 24");
      attr_dev(svg0, "class", "svelte-m9pjbw");
      add_location(svg0, file4, 142, 6, 2926);
      attr_dev(button0, "class", "svelte-m9pjbw");
      add_location(button0, file4, 141, 4, 2867);
      attr_dev(path1, "d", "M9.984 6l6 6-6 6-1.406-1.406 4.594-4.594-4.594-4.594z");
      add_location(path1, file4, 149, 8, 3210);
      attr_dev(svg1, "role", "presentation");
      attr_dev(svg1, "viewBox", "0 0 24 24");
      attr_dev(svg1, "class", "svelte-m9pjbw");
      add_location(svg1, file4, 148, 6, 3156);
      attr_dev(button1, "class", "svelte-m9pjbw");
      add_location(button1, file4, 147, 4, 3095);
      attr_dev(div0, "class", "nav svelte-m9pjbw");
      add_location(div0, file4, 140, 2, 2845);
      attr_dev(div1, "class", "carousel svelte-m9pjbw");
      attr_dev(div1, "style", div1_style_value = `transform: translate3d(${/*translateX*/
      ctx[4]}px, 0, 0);`);
      add_location(div1, file4, 153, 2, 3315);
      attr_dev(div2, "class", "container svelte-m9pjbw");
      add_location(div2, file4, 139, 0, 2819);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div2, anchor);
      append_dev(div2, div0);
      append_dev(div0, button0);
      append_dev(button0, svg0);
      append_dev(svg0, path0);
      ctx[10](button0);
      append_dev(div0, t0);
      append_dev(div0, button1);
      append_dev(button1, svg1);
      append_dev(svg1, path1);
      ctx[11](button1);
      append_dev(div2, t1);
      append_dev(div2, div1);
      mount_component(clickoutside, div1, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            window_1,
            "resize",
            /*updatePosition*/
            ctx[7],
            false,
            false,
            false
          ),
          listen_dev(
            button0,
            "click",
            /*left*/
            ctx[6],
            false,
            false,
            false
          ),
          listen_dev(
            button1,
            "click",
            /*right*/
            ctx[5],
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      const clickoutside_changes = {};
      if (dirty & /*left_nav_button, right_nav_button, image_elements*/
      14)
        clickoutside_changes.exclude = [
          /*left_nav_button*/
          ctx2[1],
          /*right_nav_button*/
          ctx2[2],
          .../*image_elements*/
          ctx2[3]
        ];
      if (dirty & /*$$scope, images, image_elements*/
      524297) {
        clickoutside_changes.$$scope = { dirty, ctx: ctx2 };
      }
      clickoutside.$set(clickoutside_changes);
      if (!current || dirty & /*translateX*/
      16 && div1_style_value !== (div1_style_value = `transform: translate3d(${/*translateX*/
      ctx2[4]}px, 0, 0);`)) {
        attr_dev(div1, "style", div1_style_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(clickoutside.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(clickoutside.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div2);
      ctx[10](null);
      ctx[11](null);
      destroy_component(clickoutside);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment4.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance4($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Carousel", slots, []);
  let { images } = $$props;
  let { curr_idx = 0 } = $$props;
  let left_nav_button;
  let right_nav_button;
  const image_elements = new Array(images.length);
  let translateX = -curr_idx * window.innerWidth;
  function increment(num) {
    return num >= images.length - 1 ? 0 : num + 1;
  }
  function decrement(num) {
    return num == 0 ? images.length - 1 : num - 1;
  }
  function right() {
    $$invalidate(9, curr_idx = increment(curr_idx));
    updatePosition();
  }
  function left() {
    $$invalidate(9, curr_idx = decrement(curr_idx));
    updatePosition();
  }
  function updatePosition() {
    $$invalidate(4, translateX = -curr_idx * window.innerWidth);
  }
  const debouncedClose = debounce(close, 100, true);
  function handleClose() {
    debouncedClose();
  }
  $$self.$$.on_mount.push(function() {
    if (images === void 0 && !("images" in $$props || $$self.$$.bound[$$self.$$.props["images"]])) {
      console.warn("<Carousel> was created without expected prop 'images'");
    }
  });
  const writable_props = ["images", "curr_idx"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Carousel> was created with unknown prop '${key}'`);
  });
  function button0_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      left_nav_button = $$value;
      $$invalidate(1, left_nav_button);
    });
  }
  function button1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      right_nav_button = $$value;
      $$invalidate(2, right_nav_button);
    });
  }
  function image_binding($$value, i) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      image_elements[i] = $$value;
      $$invalidate(3, image_elements);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("images" in $$props2)
      $$invalidate(0, images = $$props2.images);
    if ("curr_idx" in $$props2)
      $$invalidate(9, curr_idx = $$props2.curr_idx);
  };
  $$self.$capture_state = () => ({
    Image: Image_default,
    fade,
    close,
    debounce,
    ClickOutside: ClickOutside_default,
    images,
    curr_idx,
    left_nav_button,
    right_nav_button,
    image_elements,
    translateX,
    increment,
    decrement,
    right,
    left,
    updatePosition,
    debouncedClose,
    handleClose
  });
  $$self.$inject_state = ($$props2) => {
    if ("images" in $$props2)
      $$invalidate(0, images = $$props2.images);
    if ("curr_idx" in $$props2)
      $$invalidate(9, curr_idx = $$props2.curr_idx);
    if ("left_nav_button" in $$props2)
      $$invalidate(1, left_nav_button = $$props2.left_nav_button);
    if ("right_nav_button" in $$props2)
      $$invalidate(2, right_nav_button = $$props2.right_nav_button);
    if ("translateX" in $$props2)
      $$invalidate(4, translateX = $$props2.translateX);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    images,
    left_nav_button,
    right_nav_button,
    image_elements,
    translateX,
    right,
    left,
    updatePosition,
    handleClose,
    curr_idx,
    button0_binding,
    button1_binding,
    image_binding
  ];
}
var Carousel = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance4, create_fragment4, safe_not_equal, { images: 0, curr_idx: 9 }, add_css3);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Carousel",
      options,
      id: create_fragment4.name
    });
  }
  get images() {
    throw new Error("<Carousel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set images(value) {
    throw new Error("<Carousel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get curr_idx() {
    throw new Error("<Carousel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set curr_idx(value) {
    throw new Error("<Carousel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Carousel_default = Carousel;

// node_modules/svelte-images/src/Images/carousel.js
var open2 = (images, curr_idx) => {
  open(Carousel_default, { images, curr_idx });
};
var close2 = close;

// node_modules/svelte-images/src/Images/Images.svelte
var file5 = "node_modules/svelte-images/src/Images/Images.svelte";
function add_css4(target) {
  append_styles(target, "svelte-13fsqet", ".svelte-images-gallery.svelte-13fsqet{display:flex;flex-flow:row wrap;align-items:flex-start}.svelte-images-gallery img{width:100%;min-height:50px;height:auto !important;cursor:pointer;margin:calc(var(--gutter) * 2px)}.svelte-images-gallery img:hover{opacity:0.5;transition:none;filter:grayscale(0.5) blur(1px)}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiSW1hZ2VzLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUEyQkUsc0JBQXNCLGVBQUMsQ0FBQSxBQUNyQixPQUFPLENBQUUsSUFBSSxDQUNiLFNBQVMsQ0FBRSxHQUFHLENBQUMsSUFBSSxDQUNuQixXQUFXLENBQUUsVUFBVSxBQUV6QixDQUFBLEFBRVEsMEJBQTBCLEFBQUUsQ0FBQSxBQUNsQyxLQUFLLENBQUUsSUFBSSxDQUNYLFVBQVUsQ0FBRSxJQUFJLENBQ2hCLE1BQU0sQ0FBRSxJQUFJLENBQUMsVUFBVSxDQUN2QixNQUFNLENBQUUsT0FBTyxDQUNmLE1BQU0sQ0FBRSxLQUFLLElBQUksUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxBQUNuQyxDQUFBLEFBQ1EsZ0NBQWdDLEFBQUUsQ0FBQSxBQUN4QyxPQUFPLENBQUUsR0FBRyxDQUNaLFVBQVUsQ0FBRSxJQUFJLENBQ2hCLE1BQU0sQ0FBRSxVQUFVLEdBQUcsQ0FBQyxDQUFDLEtBQUssR0FBRyxDQUFDLEFBQ2xDLENBQUEiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiSW1hZ2VzLnN2ZWx0ZSJdfQ== */");
}
function get_each_context2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[9] = list[i];
  child_ctx[11] = i;
  return child_ctx;
}
function create_each_block2(ctx) {
  let image;
  let current;
  function func() {
    return (
      /*func*/
      ctx[6](
        /*i*/
        ctx[11]
      )
    );
  }
  image = new Image_default({
    props: {
      imageProps: {
        .../*image*/
        ctx[9],
        src: (
          /*image*/
          ctx[9].thumbnail || /*image*/
          ctx[9].src
        ),
        alt: (
          /*image*/
          ctx[9].alt || ""
        ),
        style: (
          /*numCols*/
          ctx[2] != void 0 ? `width: ${100 / /*numCols*/
          ctx[2] - 6}%;` : "max-width: 200px;"
        )
      },
      onClick: func
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(image.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(image, target, anchor);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      const image_changes = {};
      if (dirty & /*images, numCols*/
      5)
        image_changes.imageProps = {
          .../*image*/
          ctx[9],
          src: (
            /*image*/
            ctx[9].thumbnail || /*image*/
            ctx[9].src
          ),
          alt: (
            /*image*/
            ctx[9].alt || ""
          ),
          style: (
            /*numCols*/
            ctx[2] != void 0 ? `width: ${100 / /*numCols*/
            ctx[2] - 6}%;` : "max-width: 200px;"
          )
        };
      image.$set(image_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(image.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(image.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(image, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block2.name,
    type: "each",
    source: "(53:2) {#each images as image, i}",
    ctx
  });
  return block;
}
function create_if_block2(ctx) {
  let modal;
  let current;
  modal = new Modal_default({ $$inline: true });
  const block = {
    c: function create() {
      create_component(modal.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(modal, target, anchor);
      current = true;
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(modal.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(modal.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(modal, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block2.name,
    type: "if",
    source: "(60:0) {#if showModal}",
    ctx
  });
  return block;
}
function create_fragment5(ctx) {
  let div;
  let t;
  let if_block_anchor;
  let current;
  let each_value = (
    /*images*/
    ctx[0]
  );
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block2(get_each_context2(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  let if_block = (
    /*showModal*/
    ctx[4] && create_if_block2(ctx)
  );
  const block = {
    c: function create() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      attr_dev(div, "class", "svelte-images-gallery svelte-13fsqet");
      set_style(
        div,
        "--gutter",
        /*gutter*/
        ctx[1]
      );
      add_location(div, file5, 48, 0, 1053);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(div, null);
      }
      ctx[7](div);
      insert_dev(target, t, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*images, numCols, undefined, popModal*/
      37) {
        each_value = /*images*/
        ctx2[0];
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context2(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block2(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(div, null);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
      if (!current || dirty & /*gutter*/
      2) {
        set_style(
          div,
          "--gutter",
          /*gutter*/
          ctx2[1]
        );
      }
      if (
        /*showModal*/
        ctx2[4]
      ) {
        if (if_block) {
          if (dirty & /*showModal*/
          16) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block2(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      destroy_each(each_blocks, detaching);
      ctx[7](null);
      if (detaching)
        detach_dev(t);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment5.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance5($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Images", slots, []);
  let { images = [] } = $$props;
  let { gutter = 2 } = $$props;
  let { numCols } = $$props;
  const popModal = (idx) => setTimeout(
    () => {
      open2(images, idx);
    },
    0
  );
  let galleryElems;
  let galleryElem;
  let showModal;
  onMount(() => {
    galleryElems = document.getElementsByClassName("svelte-images-gallery");
    const index = Array.prototype.findIndex.call(galleryElems, (elem) => elem === galleryElem);
    $$invalidate(4, showModal = index === 0);
  });
  $$self.$$.on_mount.push(function() {
    if (numCols === void 0 && !("numCols" in $$props || $$self.$$.bound[$$self.$$.props["numCols"]])) {
      console.warn("<Images> was created without expected prop 'numCols'");
    }
  });
  const writable_props = ["images", "gutter", "numCols"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Images> was created with unknown prop '${key}'`);
  });
  const func = (i) => popModal(i);
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      galleryElem = $$value;
      $$invalidate(3, galleryElem);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("images" in $$props2)
      $$invalidate(0, images = $$props2.images);
    if ("gutter" in $$props2)
      $$invalidate(1, gutter = $$props2.gutter);
    if ("numCols" in $$props2)
      $$invalidate(2, numCols = $$props2.numCols);
  };
  $$self.$capture_state = () => ({
    onMount,
    Image: Image_default,
    Modal: Modal_default,
    open: open2,
    close: close2,
    images,
    gutter,
    numCols,
    popModal,
    galleryElems,
    galleryElem,
    showModal
  });
  $$self.$inject_state = ($$props2) => {
    if ("images" in $$props2)
      $$invalidate(0, images = $$props2.images);
    if ("gutter" in $$props2)
      $$invalidate(1, gutter = $$props2.gutter);
    if ("numCols" in $$props2)
      $$invalidate(2, numCols = $$props2.numCols);
    if ("galleryElems" in $$props2)
      galleryElems = $$props2.galleryElems;
    if ("galleryElem" in $$props2)
      $$invalidate(3, galleryElem = $$props2.galleryElem);
    if ("showModal" in $$props2)
      $$invalidate(4, showModal = $$props2.showModal);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [images, gutter, numCols, galleryElem, showModal, popModal, func, div_binding];
}
var Images = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance5, create_fragment5, safe_not_equal, { images: 0, gutter: 1, numCols: 2 }, add_css4);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Images",
      options,
      id: create_fragment5.name
    });
  }
  get images() {
    throw new Error("<Images>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set images(value) {
    throw new Error("<Images>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get gutter() {
    throw new Error("<Images>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set gutter(value) {
    throw new Error("<Images>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get numCols() {
    throw new Error("<Images>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set numCols(value) {
    throw new Error("<Images>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Images_default = Images;
export {
  carousel_exports as Carousel,
  Images_default as Images
};
//# sourceMappingURL=svelte-images.js.map
